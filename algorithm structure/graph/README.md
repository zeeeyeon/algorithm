# ê·¸ë˜í”„(Graph) ğŸ—¼

> ### ê°œë…
> - ì•„ì´í…œ(ì‚¬ë¬¼ ë˜ëŠ” ì¶”ìƒì  ê°œë…)ë“¤ê³¼ ì´ë“¤ ì‚¬ì´ì˜ ì—°ê²° ê´€ê³„ë¥¼ í‘œí˜„
> - ì •ì (Vertex) ì§‘í•©ê³¼ ì´ë“¤ì„ ì—°ê²°í•˜ëŠ” ê°„ì„ (Edge)ë“¤ì˜ ì§‘í•©ìœ¼ë¡œ êµ¬ì„±ëœ ìë£Œêµ¬ì¡°
> - ì„ í˜• ìë£Œêµ¬ì¡°ë‚˜ íŠ¸ë¦¬ ìë£Œêµ¬ì¡°ë¡œ í‘œí˜„í•˜ê¸° ì–´ë ¤ìš´ N:N ê´€ê³„ë¥¼ ê°€ì§€ëŠ” ì›ì†Œë¥¼ í‘œí˜„í•˜ê¸° ìš©ì´

> ### ê·¸ë˜í”„ ìœ í˜•
> ![img.png](img.png)
> - ë¬´í–¥ ê·¸ë˜í”„(Undirected Graph) : ì¹œêµ¬
> - ìœ í–¥ ê·¸ë˜í”„(Directed Graph) : ë„ë¡œ(ì–‘ë°©í–¥), ì§€í•˜ì² , (í¸ë„ë¡œ ìƒê°ë‚˜ëŠ” ê²ƒë“¤) íŒ”ë¡œìš°
> - ê°€ì¤‘ì¹˜ ê·¸ë˜í”„(Weighted Graph)[ìœ í–¥ ë¬´í–¥ ë‘˜ ë‹¤ ê°€ëŠ¥] : ë„ë¡œê±´ì„¤(ë¹„ìš©), ë¹„í–‰ê¸°(ê¸ˆì•¡), ê³„ë‹¨ ì„œë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ”ë° ë¹„ìš©ì´ ë“œëŠ” ê²ƒ
> - ì‚¬ì´í´ ì—†ëŠ” ë°©í–¥ ê·¸ë˜í”„(DAG, Directed Acyclic Graph) : íŠ¸ë¦¬
>
> ![img_1.png](img_1.png)
> - ì™„ì „ ê·¸ë˜í”„ : ì •ì ë“¤ì— ëŒ€í•´ ê°€ëŠ¥í•œ ëª¨ë“  ê°„ì„ ë“¤ì„ ê°€ì§„ ê·¸ë˜í”„
> - ë¶€ë¶„ ê·¸ë˜í”„ : ì›ë˜ ê·¸ë˜í”„ì—ì„œ ì¼ë¶€ ì •ì ì´ë‚˜ ê°„ì„ ì„ ì œì™¸í•œ ê·¸ë˜í”„

> ### ê·¸ë˜í”„ ê²½ë¡œ
> - ê°„ì„ ë“¤ì„ ìˆœì„œëŒ€ë¡œ ë‚˜ì—´í•œ ê²ƒ
> - ê²½ë¡œ ì¤‘ í•œ ì •ì ì„ ìµœëŒ€í•œ í•œë²ˆë§Œ ì§€ë‚˜ëŠ” ê²½ë¡œë¥¼ ë‹¨ìˆœê²½ë¡œë¼ í•¨.
> - ì‹œì‘í•œ ì •ì ì—ì„œ ëë‚˜ëŠ” ê²½ë¡œë¥¼ ì‚¬ì´í´ì´ë¼ê³  í•¨.

> ### ê·¸ë˜í”„ í‘œí˜„
> - ê°„ì„ ì˜ ì •ë³´ë¥¼ ì €ì¥í•˜ëŠ” ë°©ì‹, ë©”ëª¨ë¦¬ë‚˜ ì„±ëŠ¥ì„ ê³ ë ¤í•´ì„œ ê²°ì • <br/>
> - 1. ì¸ì ‘ í–‰ë ¬ : 2ì°¨ì› ë°°ì—´ì„ ì´ìš©í•´ì„œ ê°„ì„  ì •ë³´ë¥¼ ì €ì¥ 
>>  - ì¥ì  : ì—°ê²° ì—¬ë¶€ë¥¼ í•œ ë²ˆì— íƒìƒ‰ ê°€ëŠ¥ (ì—°ê²°ì´ ì•ˆë˜ì–´ ìˆë‹¤ ë¼ëŠ” ì •ë³´ë„ í•¨ê»˜ ì €ì¥)
>>  - ë‹¨ì  : ë©”ëª¨ë¦¬ ë‚­ë¹„ê°€ ì‹¬í•˜ë‹¤.
> - 2. ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ : ê° ì •ì ë§ˆë‹¤ í•´ë‹¹ ì •ì ìœ¼ë¡œ ë‚˜ê°€ëŠ” ê°„ì„ ì˜ ì •ë³´ë¥¼ ì €ì¥ 
>>  - ì¥ì  : ë©”ëª¨ë¦¬ í™œìš©ì´ íš¨ìœ¨ì 
>>  - ë‹¨ì  : ì—°ê²° ì •ë³´ í™•ì¸ì´ ì–´ë µë‹¤. (ì—°ê²° ëœ ì •ë³´ë§Œ ì €ì¥)
> - 3. ê°„ì„ ì˜ ë°°ì—´ : ê°„ì„ (ì‹œì‘ ì •ì , ë ì •ì )ì„ ë°°ì—´ì— ì—°ì†ì ìœ¼ë¡œ ì €ì¥


> ### ì¸ì ‘ ë¦¬ìŠ¤íŠ¸
> ![img_2.png](img_2.png)
> - í•˜ë‚˜ì˜ ì •ì ì— ëŒ€í•œ ì¸ì  ì •ì ë“¤ì„ ê° ì—°ê²° ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥ (ì‚½ì… ì‚­ì œê°€ ë§ê¸° ë•Œë¬¸)
>> - ë¬´ë°©í–¥ ê·¸ë˜í”„ : ë…¸ë“œìˆ˜ = ê°„ì„ ì˜ ìˆ˜ * 2
>> - ë°©í–¥ ê·¸ë˜í”„ : ë…¸ë“œ ìˆ˜ = ê°„ì„ ì˜ ìˆ˜
> ![img_3.png](img_3.png)


> - ê·¸ë˜í”„ ìˆœíšŒ : ë¹„ì„ í˜•êµ¬ì¡°ì¸ ê·¸ë˜í”„ë¡œ í¬í˜„ëœ ëª¨ë“  ì •ì ì„ ë¹ ì§ì—†ì´ íƒìƒ‰í•˜ëŠ” ê²ƒ
> ![img_4.png](img_4.png)
> - ëŒê¹Œì§€ ì „ë‹¬ì„ í•´ë´ì•¼ 1ë²ˆ ê³„ì‚° ê°€ëŠ¥, ê²½ìš°ì˜ ìˆ˜ë¥¼ ë‹¤ ë³´ì (DFS)
> - í¼ì ¸ë‚˜ê°€ë©´ì„œ ë¬¸ì œê°€ í•´ê²° (BFS)

---
---

# ê¹Šì´ ìš°ì„  íƒìƒ‰(Depth First Search, DFS) ğŸ›©

> ### ê°œë…
> - ì‹œì‘ ì •ì ì˜ í•œ ë°©í–¥ìœ¼ë¡œ ê°ˆ ìˆ˜ ìˆëŠ” ê²½ë¡œê°€ ìˆëŠ” ê³³ê¹Œì§€ ê¹Šì´ íƒìƒ‰í•´ ê°€ë‹¤ê°€ ë” ì´ìƒ ê°ˆ ê³³ì´ ì—†ê²Œ ë˜ë©´, ê°€ì¥ ë§ˆì§€ë§‰ì— ë§Œë‚¬ë˜ ê°ˆë¦¼ê¸¸ ê°„ì„ ì´ ìˆëŠ” ì •ì ìœ¼ë¡œ ë˜ëŒì•„ì™€ì„œ ë‹¤ë¥¸ ë°©í–¥ì˜ ì •ì ìœ¼ë¡œ íƒìƒ‰ì„ ê³„ì† ë°˜ë³µí•˜ì—¬ ê²°êµ­ ëª¨ë“  ì •ì ì„ ë°©ë¬¸í•˜ëŠ” ìˆœíšŒë°©ë²•
> - ê°€ì¥ ë§ˆì§€ë§‰ì— ë§Œë‚¬ë˜ ê°ˆë¦¼ê¸¸ì˜ ì •ì ìœ¼ë¡œ ë˜ëŒì•„ê°€ì„œ ë‹¤ì‹œ ê¹Šì´ ìš°ì„  íƒìƒ‰ì„ ë°˜ë³µí•´ì•¼ í•˜ë¯€ë¡œ í›„ì…ì„ ì¶œ êµ¬ì¡°ì˜ ìŠ¤íƒ ì‚¬ìš©

```

# ì‹œì‘ì  : 1ë²ˆë¶€í„° ì‹œì‘
# ëì  : 1ë²ˆì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ëª¨ë“  ì •ì ì„ ë°©ë¬¸í•˜ë©´ ì¢…ë£Œ
(visited ì²˜ë¦¬ ë•ë¶„ì—, ê¸°ì €ì¡°ê±´ ì—†ì´ë„ ìì—°ìŠ¤ëŸ½ê²Œ ì¢…ë£Œë¨)

def dfs(node):
    print(node, end=' ')  # í˜„ì¬ ë…¸ë“œ ì¶œë ¥

    # í˜„ì¬ ì •ì ì—ì„œ ì—°ê²°ë˜ì–´ ìˆëŠ” ë…¸ë“œë“¤ì„ íƒìƒ‰
    for next_node in graph[node]:
        if visited[next_node]:      # ì´ë¯¸ ë°©ë¬¸í–ˆë‹¤ë©´ í†µê³¼
            continue

        visited[next_node] = 1      # ë°©ë¬¸ì²˜ë¦¬
        dfs(next_node)              # ë‹¤ìŒ ì •ì ìœ¼ë¡œ ì´ë™


N, M = map(int, input().split())
# ë¹„ì–´ìˆëŠ” ë¦¬ìŠ¤íŠ¸ë¥¼ N + 1ë²ˆ ë°˜ë³µí•˜ë©´ì„œ ìƒì„±
# 1. ë¹„ì–´ìˆëŠ” ë¦¬ìŠ¤íŠ¸ : ì•„ì§ ê°ˆ ìˆ˜ ìˆëŠ” ê³³ì´ ì—†ë‹¤.
# 2. N + 1 ë²ˆ : 0ë²ˆ ì¸ë±ìŠ¤ë¥¼ ë²„ë¦°ë‹¤. (ë¬¸ì œì—ì„œ ë…¸ë“œë²ˆí˜¸ê°€ 1ë²ˆë¶€í„° ì‹œì‘)
# ---> ì¸ì ‘ë¦¬ìŠ¤íŠ¸ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ì•„ë˜ì™€ ê°™ì´ ì •ì˜

graph = [[] for _ in range(N + 1)]   

# ì—°ê²° ì •ë³´ë¥¼ ì €ì¥
visited = [0] * (N + 1)
for _ in range(M):
    s, e = map(int, input().split())
    # ì–‘ë°©í–¥ ê·¸ë˜í”„ì´ë¯€ë¡œ, ì‹œì‘ <-> ëì ì„ ë°”ê¾¸ë©´ì„œ ì €ì¥
    graph[s].append(e)
    graph[e].append(s)  # ë¬¸ì œê°€ ë°©í–¥ ê·¸ë˜í”„ë¼ë©´, ë°”ê¾¼ ì •ë³´ë¥¼ ì €ì¥í•˜ë©´ ë²„ê·¸ë‚¨!

visited[1] = 1      # ì¶œë°œì§€ ë°©ë¬¸ì²˜ë¦¬
dfs(1)

```
---
---

# ë„ˆë¹„ ìš°ì„  íƒìƒ‰(Breadth First Search, BFS) ğŸ›©

> ### ê°œë…
> - íƒìƒ‰ ì‹œì‘ì ì˜ ì¸ì ‘í•œ ì •ì ë“¤ì„ ë¨¼ì € ëª¨ë‘ ì°¨ë¡€ë¡œ ë°©ë¬¸í•œ í›„ì—, ë°©ë¬¸í–ˆë˜ ì ì„ ì‹œì‘ì ìœ¼ë¡œ í•˜ì—¬ ë‹¤ì‹œ ì¸ì ‘í•œ ì •ì ë“¤ì„ ì°¨ë¡€ëŒ€ë¡œ ë°©ë¬¸í•˜ëŠ” ë°©ì‹
> - ì¸ì ‘í•œ ì •ì ë“¤ì— ëŒ€í•´ íƒìƒ‰ì„ í•œ í›„, ì°¨ë¡€ë¡œ ë‹¤ì‹œ ë„ˆë¹„ìš°ì„ íƒìƒ‰ì„ ì§„í–‰í•´ì•¼ í•˜ë¯€ë¡œ, ì„ ì…ì„ ì¶œ í˜•íƒœì˜ ìë£Œêµ¬ì¡°ì¸ íë¥¼ í™œìš©í•¨
> ![img_5.png](img_5.png)


```
def bfs(node):
    q = [node]     

    # q ì— ì €ì¥ë˜ëŠ” ë°ì´í„° : ë‹¤ìŒì— ì²˜ë¦¬í•  ë°ì´í„°(í›„ë³´êµ°)
    while q:
        now = q.pop(0)

        print(now, end=' ')  # í˜„ì¬ ë…¸ë“œ ì¶œë ¥

        for next_node in graph[now]:
            if visited[next_node]:  # ì´ë¯¸ ë°©ë¬¸í•œ ì •ì ì´ë©´ í†µê³¼
                continue

            visited[next_node] = 1  # ë°©ë¬¸ ì²˜ë¦¬
            q.append(next_node)     # í›„ë³´êµ°ì— ì¶”ê°€(ìˆœì„œê°€ ë˜ë©´ ì²˜ë¦¬)

# í•µì‹¬ : ì–´ë–¤ ë…¸ë“œë¥¼ ë¨¼ì € íƒìƒ‰í•  ê²ƒì¸ê°€
#   - íŠ¹ì • ì •ì ì„ ê¸°ì¤€ìœ¼ë¡œ í¼ì ¸ë‚˜ê°€ë©´ì„œ í™•ì¸
N, M = map(int, input().split())
graph = [[] for _ in range(N + 1)]
visited = [0] * (N + 1)
for _ in range(M):
    s, e = map(int, input().split())
    graph[s].append(e)
    graph[e].append(s)

visited[1] = 1
bfs(1)
```
---
---
# Union - Find ğŸ¡

> ### Disjoint_sets (ì„œë¡œì†Œ ì§‘í•©)
> - ì„œë¡œì†Œ ë˜ëŠ” ìƒí˜¸ë² íƒ€ ì§‘í•©ë“¤ì€ ì„œë¡œ ì¤‘ë³µ í¬í•¨ëœ ì›ì†Œê°€ ì—†ëŠ” ì§‘í•©, êµì§‘í•©ì´ ì—†ìŒ
> - ì§‘í•©ì— ì†í•œ í•˜ë‚˜ì˜ íŠ¹ì • ë©¤ë²„ë¥¼ í†µí•´ ê° ì§‘í•©ë“¤ì„ êµ¬ë¶„ => ëŒ€í‘œì(representative)

> ### ìƒí˜¸ë² íƒ€ ì§‘í•©ì„ í‘œí˜„í•˜ëŠ” ë°©ë²•
> - ì—°ê²° ë¦¬ìŠ¤íŠ¸
> - íŠ¸ë¦¬
>> - ìƒí˜¸ë² íƒ€ ì§‘í•© ì—°ì‚°
>> - Make-Set(x) : ì´ˆê¸° ì„¤ì •
>> - Find-Set(x) : ëŒ€í‘œìê°€ ëˆ„êµ¬ì¼ê¹Œ?
>> - Union(x, y) : ê°™ì€ ê·¸ë£¹ìœ¼ë¡œ ë¬¶ì–´ì£¼ê¸°
>
> ![img_6.png](img_6.png)

> ### ì—°ê²°ë¦¬ìŠ¤íŠ¸
> - ê°™ì€ ì§‘í•©ì˜ ì›ì†Œë“¤ì€ í•˜ë‚˜ì˜ ì—°ê²°ë¦¬ìŠ¤íŠ¸ë¡œ ê´€ë¦¬
> - ë§¨ ì•ì˜ ì›ì†Œë¥¼ ì§‘í•©ì˜ ëŒ€í‘œ ì›ì†Œë¡œ ì‚¼ëŠ”ë‹¤.
> - ê° ì›ì†ŒëŠ” ì§‘í•©ì˜ ëŒ€í‘œì›ì†Œë¥¼ ê°€ë¦¬í‚¤ëŠ” ë§í¬ë¥¼ ê°–ëŠ”ë‹¤.
> ![img_7.png](img_7.png)

> ### íŠ¸ë¦¬
> - í•˜ë‚˜ì˜ ì§‘í•©ì„ í•˜ë‚˜ì˜ íŠ¸ë¦¬ë¡œ í‘œí˜„
> - ìì‹ ë…¸ë“œê°€ ë¶€ëª¨ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë©° ë£¨íŠ¸ ë…¸ë“œê°€ ëŒ€í‘œìê°€ ëœë‹¤.
> ![img_8.png](img_8.png)
>
>> ![img_9.png](img_9.png)
>> ![img_10.png](img_10.png)
>> ![img_11.png](img_11.png)
> >> - ëŒ€í‘œìë¼ë¦¬ ì—°ê²°í•˜ì—¬ ë°”ë¼ë³´ê²Œ í•˜ëŠ” ê²ƒ

```
# ìê¸° ìì‹ ì„ ê°€ë¥´í‚¤ë„ë¡ ë§Œë“¤ê¸°
def make_set(n):
    p = [i for i in range(n)]  # ê° ì›ì†Œì˜ ë¶€ëª¨ë¥¼ ìì‹ ìœ¼ë¡œ ì´ˆê¸°í™”
    return p


def find(x):
    if parents[x] == x:        # x ìê¸° ìì‹ ì´ xë¥¼ ë°”ë¼ë´„ == í•´ë‹¹ ì§‘í•©ì˜ ëŒ€í‘œìë¥¼ ì°¾ì•˜ë‹¤ 
        return x

    # xì˜ ë¶€ëª¨ê°€ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ì •ì ë¶€í„° ë‹¤ì‹œ ëŒ€í‘œìë¥¼ íƒìƒ‰
    return find(parents[x])


def union(x, y):
    # x, yì˜ ëŒ€í‘œìë¥¼ ì°¾ì
    root_x = find(x)
    root_y = find(y)

    if root_x == root_y:  # ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë©´ ë (ê°™ì€ ì§‘í•©ì´ë©´ union ì—°ì‚° í•˜ì§€ ì•ŠìŒ)
        return

    # ë‹¤ë¥¸ ì§‘í•©ì´ë¼ë©´ ë” ì‘ì€ ë£¨íŠ¸ë…¸íŠ¸ì— í•©ì¹œë‹¤.
    # ë¬¸ì œì— ë”°ë¼ ë‹¤ë¥´ì§€ë§Œ(ìš°ì„ ì€ ë” ì‘ì€ ë…¸ë“œë¡œ í•©ì³ì¤Œ)
    if root_x < root_y:
        parents[y] = root_x     # yê°€ ë°”ë¼ë³´ëŠ” ë¶€ëª¨ëŠ” xì˜ ëŒ€í‘œì
    else:
        parents[x] = root_y


# ì˜ˆì œ ì‚¬ìš©ë²•
n = 7  # ì›ì†Œì˜ ê°œìˆ˜
parents = make_set(n)

union(1, 3)         # 1ì˜ ëŒ€í‘œì 3ì˜ ëŒ€í‘œìë¥¼ í•©ì¹˜ëŠ” ê³¼ì •
union(2, 3)
union(5, 6)

# ë³€í•˜ëŠ” ê²ƒì€ í•­ìƒ parents, ì§„í–‰ ì‚¬í•­ì„ ì•Œ ìˆ˜ ìˆìŒ.
print(parents)      # ëŒ€í‘œìì˜ ìˆ˜ == ì§‘í•©ì˜ ìˆ˜

print('find_set(6) = ', find(6))

target_x = 2
target_y = 3

# ì›ì†Œ 1ê³¼ ì›ì†Œ 2ê°€ ê°™ì€ ì§‘í•©ì— ì†í•´ ìˆëŠ”ì§€ í™•ì¸
if find(target_x) == find(target_y):
    print(f"ì›ì†Œ {target_x}ê³¼ ì›ì†Œ {target_y}ëŠ” ê°™ì€ ì§‘í•©ì— ì†í•´ ìˆìŠµë‹ˆë‹¤.")
else:
    print(f"ì›ì†Œ {target_x}ê³¼ ì›ì†Œ {target_y}ëŠ” ë‹¤ë¥¸ ì§‘í•©ì— ì†í•´ ìˆìŠµë‹ˆë‹¤.")
```

> - ìœ„ ì½”ë“œì˜ ë¬¸ì œì 
> ![img_12.png](img_12.png)


> ### Path Compressionì˜ ì˜ˆì‹œ
> ![img_13.png](img_13.png)
> - dê°€ ê°€ë¦¬í‚¤ëŠ” ë¶€ëª¨ê°€ ëŒ€í‘œìë©´ ë¦¬í„´ìœ¼ë¡œ eê°€ ë°”ë¡œ ê°€ë¦¬í‚¬ ìˆ˜ ìˆë„ë¡ ìˆ˜ì •

```
# ìê¸° ìì‹ ì„ ê°€ë¥´í‚¤ë„ë¡ ë§Œë“¤ê¸°
def make_set(n):
    p = [i for i in range(n)]  # ê° ì›ì†Œì˜ ë¶€ëª¨ë¥¼ ìì‹ ìœ¼ë¡œ ì´ˆê¸°í™”
    return p


def find(x):
    if parents[x] == x:        # x ìê¸° ìì‹ ì´ xë¥¼ ë°”ë¼ë´„ == í•´ë‹¹ ì§‘í•©ì˜ ëŒ€í‘œìë¥¼ ì°¾ì•˜ë‹¤ 
        return x

# ì´ë¶€ë¶„ë§Œ ìˆ˜ì •í•˜ë©´ ê²½ë¡œ ì••ì¶•ìœ¼ë¡œ ìˆ˜ì • ë

    # xì˜ ë¶€ëª¨ê°€ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ì •ì ë¶€í„° ë‹¤ì‹œ ëŒ€í‘œìë¥¼ íƒìƒ‰
    # return find(parents[x])

    #parents[x]              # xê°€ ê°€ë¦¬í‚¤ê³  ìˆëŠ” ë¶€ëª¨
    #find(parents[x])        # x ì˜ ë¶€ëª¨ë¡œë¶€í„° ëŒ€í‘œìë¥¼ ì°¾ê¸°
    
    parents[x] = find(parents[x])
    return parents[x]

def union(x, y):
    # x, yì˜ ëŒ€í‘œìë¥¼ ì°¾ì
    root_x = find(x)
    root_y = find(y)

    if root_x == root_y:  # ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë©´ ë (ê°™ì€ ì§‘í•©ì´ë©´ union ì—°ì‚° í•˜ì§€ ì•ŠìŒ)
        return

    # ë‹¤ë¥¸ ì§‘í•©ì´ë¼ë©´ ë” ì‘ì€ ë£¨íŠ¸ë…¸íŠ¸ì— í•©ì¹œë‹¤.
    # ë¬¸ì œì— ë”°ë¼ ë‹¤ë¥´ì§€ë§Œ(ìš°ì„ ì€ ë” ì‘ì€ ë…¸ë“œë¡œ í•©ì³ì¤Œ)
    if root_x < root_y:
        parents[y] = root_x     # yê°€ ë°”ë¼ë³´ëŠ” ë¶€ëª¨ëŠ” xì˜ ëŒ€í‘œì
    else:
        parents[x] = root_y


# ì˜ˆì œ ì‚¬ìš©ë²•
n = 7  # ì›ì†Œì˜ ê°œìˆ˜
parents = make_set(n)

union(1, 3)         # 1ì˜ ëŒ€í‘œì 3ì˜ ëŒ€í‘œìë¥¼ í•©ì¹˜ëŠ” ê³¼ì •
union(2, 3)
union(5, 6)

# ë³€í•˜ëŠ” ê²ƒì€ í•­ìƒ parents, ì§„í–‰ ì‚¬í•­ì„ ì•Œ ìˆ˜ ìˆìŒ.
print(parents)      # ëŒ€í‘œìì˜ ìˆ˜ == ì§‘í•©ì˜ ìˆ˜

print('find_set(6) = ', find(6))

target_x = 2
target_y = 3

# ì›ì†Œ 1ê³¼ ì›ì†Œ 2ê°€ ê°™ì€ ì§‘í•©ì— ì†í•´ ìˆëŠ”ì§€ í™•ì¸
if find(target_x) == find(target_y):
    print(f"ì›ì†Œ {target_x}ê³¼ ì›ì†Œ {target_y}ëŠ” ê°™ì€ ì§‘í•©ì— ì†í•´ ìˆìŠµë‹ˆë‹¤.")
else:
    print(f"ì›ì†Œ {target_x}ê³¼ ì›ì†Œ {target_y}ëŠ” ë‹¤ë¥¸ ì§‘í•©ì— ì†í•´ ìˆìŠµë‹ˆë‹¤.")
```

> ### Rankë¥¼ ì´ìš©í•œ Union
> ![img_14.png](img_14.png)
> - subtreeì˜ ë†’ì´ë¥¼ ë­í¬(rank)ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì €ì¥
> - ë‘ ì§‘í•©ì„ í•©ì¹  ë•Œ rankê°€ ë‚®ì€ ì§‘í•©ì„ rankê°€ ë†’ì€ ì§‘í•©ì— ë¶™ì„
> - ì‚¬ìš©í•˜ëŠ” ì´ìœ  : ê·¸ë˜í”„ì˜ ê²½ìš°ì—ì„œ ì´ë¯¸ ì—°ê²°ëœ ë…¸ë“œë¼ë¦¬ ë˜ ì—°ê²°í•˜ë©´ ì‚¬ì´í´ì´ ë°œìƒ(íŠ¹ì´í•œ ìƒí™©ì´ ë°œìƒí•¨)

```
def make_set(n):
    p = [i for i in range(n)]  # ê° ì›ì†Œì˜ ë¶€ëª¨ë¥¼ ìì‹ ìœ¼ë¡œ ì´ˆê¸°í™”
    r = [0] * n                # ì‹œì‘ rankëŠ” ëª¨ë‘ 0ìœ¼ë¡œ ì´ˆê¸°í™”
    return p, r


def find(x):
    # ì›ì†Œì˜ ë¶€ëª¨ê°€ ìê¸°ìì‹ ì´ë‹¤ == ìê¸°ê°€ ê·¸ ê·¸ë£¹ì˜ ëŒ€í‘œì
    if parents[x] == x:
        return x

    # ê²½ë¡œ ì••ì¶• (path compression)ì„ í†µí•´ ë¶€ëª¨ë¥¼ ë£¨íŠ¸ë¡œ ì„¤ì •
    parents[x] = find(parents[x])
    return parents[x]


def union(x, y):
    root_x = find(x)
    root_y = find(y)

    if root_x == root_y:  # ì´ë¯¸ ê°™ì€ ì§‘í•©ì´ë©´ ë
        return

    # # rankë¥¼ ë¹„êµí•˜ì—¬ ë” ì‘ì€ íŠ¸ë¦¬ë¥¼ í° íŠ¸ë¦¬ ë°‘ì— ë³‘í•©
    if ranks[root_x] > ranks[root_y]:
        parents[root_y] = root_x
    elif ranks[root_x] < ranks[root_y]:
        parents[root_x] = root_y
    else:
        # rankê°€ ê°™ìœ¼ë©´ í•œìª½ì„ ë‹¤ë¥¸ ìª½ ì•„ë˜ë¡œ ë³‘í•©í•˜ê³  rankë¥¼ ì¦ê°€ì‹œí‚´
        parents[root_y] = root_x
        ranks[root_x] += 1


# ì˜ˆì œ ì‚¬ìš©ë²•
n = 7  # ì›ì†Œì˜ ê°œìˆ˜
parents, ranks = make_set(n)

union(1, 3)
union(2, 3)
union(5, 6)

print('find_set(6) = ', find(6))

target_x = 2
target_y = 3

# ì›ì†Œ 1ê³¼ ì›ì†Œ 2ê°€ ê°™ì€ ì§‘í•©ì— ì†í•´ ìˆëŠ”ì§€ í™•ì¸
if find(target_x) == find(target_y):
    print(f"ì›ì†Œ {target_x}ê³¼ ì›ì†Œ {target_y}ëŠ” ê°™ì€ ì§‘í•©ì— ì†í•´ ìˆìŠµë‹ˆë‹¤.")
else:
    print(f"ì›ì†Œ {target_x}ê³¼ ì›ì†Œ {target_y}ëŠ” ë‹¤ë¥¸ ì§‘í•©ì— ì†í•´ ìˆìŠµë‹ˆë‹¤.")

```

---
---

# ê·¸ë˜í”„ì˜ ìµœì†Œ ë¹„ìš© ë¬¸ì œ(graph ì‘ìš©)â›³

> ## ìµœì†Œ ë¹„ìš© ì‹ ì¥ íŠ¸ë¦¬(MST) 
>> - ê·¸ë¦¬ë”” ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼(ì‘ì€ ê²ƒë¶€í„° ì„ íƒ)
>> - Prim ì•Œê³ ë¦¬ì¦˜(ì •ì ê¸°ì¤€ìœ¼ë¡œ ìµœì†Œë¶€í„° ê°€ì)
>> - Kruskal ì•Œê³ ë¦¬ì¦˜(ì •ì  ì •ë ¬í•˜ê³  ìµœì†Œë¶€í„° ëŒ€ì‹  ì‚¬ì´í´ ìƒê°í•˜ê¸°)

> ###  ê·¸ë˜í”„ì—ì„œ ìµœì†Œ ë¹„ìš© ë¬¸ì œ
>> - ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ëŠ” ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œê°€ ë˜ëŠ” íŠ¸ë¦¬
>> - ë‘ ì •ì  ì‚¬ì´ì˜ ìµœì†Œ ë¹„ìš© ê²½ë¡œ ì°¾ê¸°

> ### ì‹ ì¥ íŠ¸ë¦¬
>> - n ê°œì˜ ì •ì ìœ¼ë¡œ ì´ë£¨ì–´ì§„ ë¬´ë°©í–¥ ê·¸ë˜í”„ì—ì„œ nê°œì˜ ì •ì ê³¼ n-1ê°œì˜ ê°„ì„ ìœ¼ë¡œ ì´ë£¨ì–´ì§„ íŠ¸ë¦¬
>> - ëª¨ë“  ì •ì ì„ ì—°ê²°í•˜ë©´ì„œ, ê°„ì„ ì´ n-1ê°œì¸ íŠ¸ë¦¬(ê³„ì¸µì ì´ë©° ì‚¬ì´í´ x)

> ### ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬ (Minimum Spanning Tree)
>> - ë¬´ë°©í–¥ ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì—ì„œ ì‹ ì¥ íŠ¸ë¦¬ë¥¼ êµ¬ì„±í•˜ëŠ” ê°„ì„ ë“¤ì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ***ìµœì†Œì¸*** ì‹ ì¥ íŠ¸ë¦¬

---
---

# Prim ì•Œê³ ë¦¬ì¦˜ğŸ’

> - í•˜ë‚˜ì˜ ì •ì ì—ì„œ ì—°ê²°ëœ ê°„ì„ ë“¤ ì¤‘ì—ì„œ í•˜ë‚˜ì”© ì„ íƒí•˜ë©´ì„œ MSTë¥¼ ë§Œë“¤ì–´ê°€ëŠ” ë°©ì‹
>> - ì„ì˜ ì •ì ì„ í•˜ë‚˜ ì„ íƒí•´ì„œ ì‹œì‘
>> - ì„ íƒí•œ ì •ì ê³¼ ì¸ì ‘í•˜ëŠ” ì •ì ë“¤ ì¤‘ì˜ ìµœì†Œ ë¹„ìš©ì˜ ê°„ì„ ì´ ì¡´ì¬í•˜ëŠ” ì •ì ì„ ì„ íƒ (BFS + ìµœì†Œ ë¹„ìš©)
>> - ëª¨ë“  ì •ì ì´ ì„ íƒë  ë•Œê¹Œì§€ ì•ì˜ ê³¼ì •ì„ ë°˜ë³µ

> - ì„œë¡œì†Œì¸ 2ê°œì˜ ì§‘í•©(2 disjoint-sets) ì •ë³´ë¥¼ ìœ ì§€
>> - íŠ¸ë¦¬ ì •ì (tree vertices) - MSTë¥¼ ë§Œë“¤ê¸° ìœ„í•´ ì„ íƒëœ ì •ì ë“¤
>> - ë¹„íŠ¸ë¦¬ ì •ì (nontree vertices) - ì„ íƒë˜ì§€ ì•Šì€ ì •ì ë“¤

> ![img_15.png](img_15.png)
> ![img_16.png](img_16.png)
> - ì •ì ìœ¼ë¡œë¶€í„° ì¸ì ‘í•œ ì •ì  ì¤‘ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ë‚®ì€ ê³³ë¶€í„° ê°€ë³´ì

```
from heapq import heappush, heappop

def prim(start):
    heap = list()
    # visitedì™€ ë™ì¼
    MST = [0] * (V)

    # ìµœì†Œ ë¹„ìš© í•©ê³„
    sum_weight = 0

    # í™ì—ì„œ ê´€ë¦¬í•´ì•¼ í•  ë°ì´í„°
    # ê°€ì¤‘ì¹˜, ì •ì  ì •ë³´
    # ì‹œì‘ì ì€ ê°€ì¤‘ì¹˜ê°€ 0
    heappush(heap, (0, start))  # 0ì„ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ (ê°€ì¤‘ì¹˜ê°€ ì œì¼ ì‘ì€ ê²ƒë¶€í„° ì •ë ¬)

    while heap:
        weight, v = heappop(heap)   # í˜„ì¬ ì‹œì ì—ì„œ ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ì‘ì€ ì •ì ì´ pop
        
        # ì´ë¯¸ ë°©ë¬¸í•œ ì§€ì ì´ë©´ í†µê³¼
        if MST[v]:
            continue

        # ë°©ë¬¸ ì²˜ë¦¬
        MST[v] = 1
        # ëˆ„ì í•© ì¶”ê°€
        sum_weight += weight

        # ê°ˆ ìˆ˜ ìˆëŠ” ë…¸ë“œë¥¼ ë³´ë©´ì„œ
        for next in range(V):
            # ê°ˆ ìˆ˜ ì—†ëŠ” ì§€ì ì´ë©´ continue
            if graph[v][next] == 0:
                continue

            # ì´ë¯¸ ë°©ë¬¸í•œ ì§€ì ì´ë©´ continue
            if MST[next]:
                continue

            heappush(heap, (graph[v][next], next))

    return sum_weight


V, E = map(int, input().split())
graph = [[0] * (V) for _ in range(V)]       

for _ in range(E):
    u, v, w = map(int, input().split())
    graph[u][v] = w
    graph[v][u] = w  # ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ë¬´ë°©í–¥ ê·¸ë˜í”„

result = prim(0)
print(f'ìµœì†Œ ë¹„ìš© = {result}')
```

---
---

# Kruskal ì•Œê³ ë¦¬ì¦˜ğŸ’

> - ê°„ì„ ì„ í•˜ë‚˜ì”© ì„ íƒí•´ì„œ MSTë¥¼ ì°¾ëŠ” ì•Œê³ ë¦¬ì¦˜
>> - 1. ìµœì´ˆ, ëª¨ë“  ê°„ì„ ì„ ê°€ì¤‘ì¹˜ì— ë”°ë¼ ì˜¤ë¦„ì°¨ìˆœìœ¼ë¡œ ì •ë ¬
>> - 2. ê°€ì¤‘ì¹˜ê°€ ê°€ì¥ ë‚®ì€ ê°„ì„ ë¶€í„° ì„ íƒí•˜ë©´ì„œ íŠ¸ë¦¬ë¥¼ ì¦ê°€ì‹œí‚´ (ì‚¬ì´í´ì´ ì¡´ì¬í•˜ë©´ì„œ ë‹¤ìŒìœ¼ë¡œ ê°€ì¤‘ì¹˜ê°€ ë‚®ì€ ê°„ì„  ì„ íƒ)
>> - 3. n-1ê°œì˜ ê°„ì„ ì´ ì„ íƒë  ë•Œê¹Œì§€ 2ë²ˆì„ ë°˜ë³µ

>> - ê°„ì„  ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ -> ì‘ì€ ê°„ì„ ë¶€í„° ë°©ë¬¸(ì‚¬ì´í´ ë°œìƒí•˜ë©´ í†µê³¼)

```
V, E = map(int, input().split())    # V ë§ˆì§€ë§‰ ì •ì , 0~Vë²ˆ ì •ì . ê°œìˆ˜ (V+1)ê°œ
edge = []
for _ in range(E):
    u, v, w = map(int, input().split())
    edge.append([u, v, w])          # ì¶œë°œ, ë„ì°©, ê°€ì¤‘ì¹˜ ë¬¶ì–´ì„œ ì €ì¥(ê°„ì„  ì •ë³´ë“¤ì„ ëª¨ë‘ ì €ì¥)
edge.sort(key=lambda x : x[2])      # ê°€ì¤‘ì¹˜ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
parents = [i for i in range(V)]     # ëŒ€í‘œì›ì†Œ ë°°ì—´


def find_set(x):
    # ìê¸° ìì‹ ì´ ëŒ€í‘œìë¼ë©´ ìê¸° ìì‹ ì„ ë¦¬í„´
    if parents[x] == x:
        return x

    parents[x] = find_set(parents[x])       # ê²½ë¡œ ì••ì¶•
    return parents[x]


def union(x, y):
    root_x = find_set(x)
    root_y = find_set(y)

    if root_x == root_y:
        return

    # ë” ì‘ì€ ë£¨íŠ¸ë…¸íŠ¸ì— í•©ì¹œë‹¤.
    if root_x < root_y:
        parents[root_y] = root_x
    else:
        parents[root_x] = root_y

# MSTì˜ ê°„ì„ ìˆ˜ N = ì •ì  ìˆ˜ - 1
cnt = 0     # ì„ íƒí•œ edgeì˜ ìˆ˜ (N-1ê°€ ë˜ë©´ ì‹ ì¥íŠ¸ë¦¬ ì™„ì„± - ì‹œê°„ íš¨ìœ¨ì„ ìœ„í•´ ì‚¬ìš©)
total = 0   # MST ê°€ì¤‘ì¹˜ì˜ í•©
print(edge)

for u, v, w in edge:
    # ì¶œë°œì ê³¼ ë„ì°©ì ì´ ê°™ì€ ê·¸ë£¹ì— ì†í•´ìˆë‹¤ë©´, ì´ë¯¸ ì—°ê²°ëœ ì¹œêµ¬ë“¤ì´ë‹¤.
    # ë‹¤ë¥¸ ì§‘í•©ì´ë¼ë©´
    if find_set(u) != find_set(v):  # ì¶œë°œì§€ì™€ ë„ì°©ì§€ê°€ ë™ì¼í•˜ë‹¤ë©´ ì‚¬ì´í´ì´ ìƒê¸°ê¸° ë•Œë¬¸
        print(u, v, w)  # ì„ íƒí•œ ìˆœì„œëŒ€ë¡œ ì¶œë ¥
        cnt += 1
        union(u, v)
        total += w
        if cnt == V - 1:  # MST êµ¬ì„±ì´ ëë‚˜ë©´
            break
            
print(f'ìµœì†Œ ë¹„ìš© = {total}')
```

---
---

# ìµœë‹¨ê²½ë¡œ(Dijkstra) ğŸ€

> - í•˜ë‚˜ì˜ ì‹œì‘ ì •ì ì—ì„œ ë ì •ì ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œ
>> - ë‹¤ìµìŠ¤íŠ¸ë¼(Dijkstra) ì•Œê³ ë¦¬ì¦˜ (ìŒì˜ ê°€ì¤‘ì¹˜ë¥¼ í—ˆìš©í•˜ì§€ ì•ŠìŒ)
>> - ë²¨ë§Œ-í¬ë“œ(Bellman-Ford) ì•Œê³ ë¦¬ì¦˜ (ìŒì˜ ê°€ì¤‘ì¹˜ í—ˆìš©)
> - ëª¨ë“  ì •ì ë“¤ì— ëŒ€í•œ ìµœë‹¨ ê²½ë¡œ
>> - í”Œë¡œì´ë“œ-ì›Œìƒ¬(Floyd-Warshall) ì•Œê³ ë¦¬ì¦˜

> ### ê°œë…
> - ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ê°€ ìˆëŠ” ê·¸ë˜í”„ì—ì„œ ë‘ ì •ì  ì‚¬ì´ì˜ ê²½ë¡œë“¤ ì¤‘ì— ê°„ì„ ì˜ ê°€ì¤‘ì¹˜ì˜ í•©ì´ ìµœì†Œì¸ ê²½ë¡œ
> - ì‹œì‘ ì •ì ì—ì„œ ê±°ë¦¬(ëˆ„ì ê°’, ì¸ì ‘ ì •ì  ì¤‘ ê°€ì¥ ëˆ„ì  ê°€ì¤‘ì¹˜ê°€ ì ì€)ê°€ ìµœì†Œì¸ ì •ì ì„ ì„ íƒí•´ ë‚˜ê°€ë©´ì„œ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ë°©ì‹
> - ì‹œì‘ ì •ì (s) ì—ì„œ ëì •ì (t) ê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œì— ì •ì  xê°€ ì¡´ì¬
> - ì´ë•Œ, ìµœë‹¨ ê²½ë¡œëŠ” sì—ì„œ xê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œì™€ xì—ì„œ tê¹Œì§€ì˜ ìµœë‹¨ ê²½ë¡œë¡œ êµ¬ì„±
> - íƒìš• ê¸°ë²•ì„ ì‚¬ìš©í•œ ì•Œê³ ì§€ë¦„ìœ¼ë¡œ MSTì˜ í”„ë¦¼ ì•Œê³ ë¦¬ì¦˜(í˜„ì¬ ì •ì ì˜ ì¸ì ‘ ì •ì  ì¤‘ ê°€ì¥ ê°€ì¤‘ì¹˜ê°€ ì‘ì€)ê³¼ ìœ ì‚¬


> ![img_17.png](img_17.png)
> ![img_18.png](img_18.png)

```
# 0ë²ˆ ë…¸ë“œì—ì„œ ê°ˆ ìˆ˜ ìˆëŠ” ë‹¤ë¥¸ ë…¸ë“œë“¤ê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ë“¤ì„ ëª¨ë‘ êµ¬í•  ìˆ˜ ìˆìŒ
# ë‹¤ìµìŠ¤íŠ¸ë¼ í•œ ë²ˆì´ë©´, í•˜ë‚˜ì˜ ì •ì  -> ë‹¤ë¥¸ ì •ì ë“¤ê¹Œì§€ì˜ ìµœë‹¨ê±°ë¦¬ë“¤ì„ ëª¨ë‘ êµ¬í•œë‹¤.

# ìŒì˜ ê°€ì¤‘ì¹˜ê¹Œì§€ ê³„ì‚°í•˜ê³  ì‹¶ë‹¤ë©´ -> ëª¨ë“  ê°„ì„ ë“¤ì— ëŒ€í•œ ìµœì†Œê°’ì„ ë”í•´ì£¼ë©´ ë¨.(ëª¨ë“  ê°„ì„ ì˜ ë²”ìœ„ë¥¼ ì–‘ìˆ˜ë¡œ ë°”ê¿”ì£¼ë©´ ë¨)

import heapq

INF = int(1e9)  # ë¬´í•œì„ ì˜ë¯¸í•˜ëŠ” ê°’ìœ¼ë¡œ 10ì–µ

# ë…¸ë“œì˜ ê°œìˆ˜, ê°„ì„ ì˜ ê°œìˆ˜ë¥¼ ì…ë ¥ë°›ê¸°
n, m = map(int, input().split())
# ì‹œì‘ ë…¸ë“œ ë²ˆí˜¸ (ë¬¸ì œì— ë”°ë¼ ë‹¤ë¦„)
start = 0
# ì¸ì ‘ë¦¬ìŠ¤íŠ¸ ë§Œë“¤ê¸°
graph = [[] for i in range(n)]
# ëˆ„ì ê±°ë¦¬ë¥¼ ì €ì¥í•  í…Œì´ë¸” - INF ë¡œ ì €ì¥
distance = [INF] * n

# ê°„ì„  ì •ë³´ë¥¼ ì…ë ¥
for _ in range(m):
    a, b, w = map(int, input().split())
    graph[a].append([b, w])     # ë‹¨ë°©í–¥ ê·¸ë˜í”„


def dijkstra(start):
    pq = []
    # ì‹œì‘ ë…¸ë“œ ìµœë‹¨ ê±°ë¦¬ëŠ” 0
    # heapq ì— ë¦¬ìŠ¤íŠ¸ë¡œ ì €ì¥í•  ë•ŒëŠ” ë§¨ ì•ì˜ ë°ì´í„°ë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ëœë‹¤.
    heapq.heappush(pq, (0, start))  # ëˆ„ì ê°’ì´ ì•ì— ë‚˜ì™€ì•¼ ìµœë‹¨ ëˆ„ì ê°’ìœ¼ë¡œ ê³„ì‚° í•  ìˆ˜ ìˆìŒ
    distance[start] = 0             # ì‹œì‘ ë…¸ë“œ ìµœë‹¨ ê±°ë¦¬ëŠ” 0

    # ìš°ì„ ìˆœìœ„ íê°€ ë¹Œ ë•Œ ê¹Œì§€ ë°˜ë³µ
    while pq:
        # ê°€ì¥ ìµœë‹¨ ê±°ë¦¬ì¸ ë…¸ë“œì— ëŒ€í•œ ì •ë³´ êº¼ë‚´ê¸°
        dist, now = heapq.heappop(pq)
        # í˜„ì¬ ë…¸ë“œê°€ ì´ë¯¸ ì²˜ë¦¬ëë‹¤ë©´ skip
        # ì˜ˆì œ ê·¸ë¦¼ : c ìœ„ì¹˜ ê°€ì¤‘ì¹˜ 3, 4ë¡œ ë„ì°©ê°€ëŠ¥
        if distance[now] < dist:
            continue

        # í˜„ì¬ ë…¸ë“œì™€ ì—°ê²°ëœ ë‹¤ë¥¸ ì¸ì ‘í•œ ë…¸ë“œ í™•ì¸
        for next in graph[now]:
            next_node = next[0]
            cost = next[1]      # ë‹¤ìŒ ë…¸ë“œì˜ ê°€ì¤‘ì¹˜

            new_cost = dist + cost  # ëˆ„ì ê°’ (í˜„ì¬ê¹Œì§€ì˜ ëˆ„ì ê°’ + ë‹¤ìŒ ë…¸ë“œì˜ ê°€ì¤‘ì¹˜)

            # ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ëŠ” ë° ë” ë§ì€ ë¹„ìš©ì´ ë“œëŠ” ê²½ìš°
            if new_cost >= distance[next_node]:
                continue

            distance[next_node] = new_cost      # next_nodeê¹Œì§€ ê°€ëŠ”ë° ë¹„ìš©ì€ new_cost
            heapq.heappush(pq, (new_cost, next_node))


# ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ ì‹¤í–‰
dijkstra(start)

# ëª¨ë“  ë…¸ë“œë¡œ ê°€ê¸° ìœ„í•œ ìµœë‹¨ ê±°ë¦¬ ì¶œë ¥
for i in range(n):
    # ë„ë‹¬í•  ìˆ˜ ì—†ëŠ” ê²½ìš°, ë¬´í•œ ì¶œë ¥
    if distance[i] == INF:
        print("INF", end=' ')
    else:
        print(distance[i], end=' ')        
```